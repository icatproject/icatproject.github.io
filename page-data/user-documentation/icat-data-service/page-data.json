{"componentChunkName":"component---src-templates-default-jsx","path":"/user-documentation/icat-data-service/","result":{"data":{"markdownRemark":{"html":"<h1>Introduction to the IDS</h1>\n<p>This component provides an \"ICAT friendly\" interface to data storage.\nThe IDS stores the data file itself and catalogues it as a Datafile\nobject in ICAT. Calls are provided to store an individual data file and\ncalls to get, query the status of, and delete groups of data files as\nspecified by the IDs of Investigations, Datasets and Datafiles. TopCAT\nmakes use of the IDS to download data.</p>\n<p>It is also possible to configure the IDS to be used in \"Read Only\" mode\nwhere data files are stored by some preexisting facility mechanism and\nthe Datafile objects must then created in ICAT to reference these files.\nThis does make the IDS less convenient for storage of derived data but\nmay be a good way to get started with the IDS.</p>\n<h1>Two Level Storage</h1>\n<p>The IDS can be configured to use a single level of storage where data\nare all available with very low latency (e.g. disk) or it may be\nconfigured to use two levels of storage known as main and archive. The\nmain storage should have low latency and the archive storage will have\nhigher latency (e.g. tape). If the volume of data makes it not practical\nto hold all data on low latency storage then two level storage must be\nused. All of the calls to the IDS may be used irrespective of whether\nsingle or two level storage is used however the archive and restore\ncalls are ignored for single level storage and the prepareData call\n(which ensures that data is brought back from archive to main storage)\nhas no value.</p>\n<p>The archive data may be stored in units corresponding to the ICAT\nDatafile or multiple files may be stored together as a zip file\ncorresponding to an ICAT Dataset. This is a configuration option. If the\narchive storage has its own aggregator to merge small files then you may\nchoose to store by Datafile but otherwise storing by Dataset is\nrecommended.</p>\n<p>When a file is written to the IDS it is first stored on main storage.\nLater it may be copied to archive storage if a two level storage model\nhas been adopted.</p>\n<p>The server provides explicit archive and restore calls however normally\nthe movement of data between main and archive storage is handled\nautomatically. The server configuration includes high and low watermark\nlevels for the size of main storage. A background process notices if the\nhigh watermark is exceeded and requests the archiving of sufficient\nfiles to bring the main data storage size down to the low water mark. A\nrestore operation will be queued if an attempt is made to access data\nthat is not in main storage.  Restoration, which runs in the background,\nmay fail. If it does then flags are set so that an error will be\ngenerated if any calls attempt to access that data. There is a \"reset\"\ncall to clear these flags.</p>\n<h1>Plugin architecture</h1>\n<p>Different facilities have different needs for external file structures.\nTo cope with this interfaces have been defined which must be implemented\nby a plugin written for your facility. Follow the link from\n<a href=\"https://repo.icatproject.org/site/ids/plugin\">https://repo.icatproject.org/site/ids/plugin</a>\nto the specific ids.plugin version you are using and follow the link\n\"Writing an IDS plugin\" which in turn has a link to the Javadoc.\nThere are interfaces for:</p>\n<ul>\n<li>MainStorageInterface</li>\n<li>ArchiveStorageInterface</li>\n<li>ZipMapperInterface which define the entry names in a zip file when a\ngroup of files are downloaded in one call to the IDS.</li>\n</ul>\n<p>Included with the interface are some partial implementations such\nas MainStorageReadOnly which is a partial implementation of a\nMainStorageInterface providing dummy implementations of those operations\nnot needed when the readOnly flag has been set in the server\nconfiguration.</p>\n<p>An example plugin is provided to support two level storage. The example\nuses a simple file system for archive storage which is not going to be\nuseful to most people -- but is easy to get started with.</p>\n<h1>ICAT Coupling</h1>\n<p>ICAT session ids are passed as an argument to most calls. The\nserver checks for READ access to the referenced data by a suitable call\nto ICAT. For put and delete operations the server checks for CREATE and\nDELETE access to the referenced data and makes the corresponding changes\nto ICAT to catalogue (create a Datafile entry in ICAT) or uncatalogue\nthe file. The server is  coded to maintain consistency with ICAT. In the\ncase of a failure of software or hardware  an orphan file may exist but\nthere should never be an entry in ICAT for which no file exists.</p>\n<h1>Accessing the service</h1>\n<p>The server exposes a REST interface using the HTTP(S) methods PUT,\nDELETE, POST and GET as appropriate. Detailed documentation for each\ncall is generated from the server code and comments in that code and can\nbe seen by following the link from\n<a href=\"https://repo.icatproject.org/site/ids/server/\">https://repo.icatproject.org/site/ids/server/</a>\nto the specific IDS\nversion your are using and then click on \"RESTful interface\". It should\nbe noted that the IDS does not follow pure REST principles with PUT,\nGET, POST etc calls to a resource as it did not prove practical to\nidentify suitable resources. Rather, in place of the name of a resource\nthe name of the call is used and consequently only one HTTP method is\ngenerally applicable.</p>\n<p>IDS clients are provided in Java and Python (follow link\nfrom <a href=\"https://repo.icatproject.org/site/ids/client/\">https://repo.icatproject.org/site/ids/client/</a> to the specific\nclient version you are using and see the \"IDS Client User Manual\" which\nhas pointers to the language specific documentation; the javadoc for the\nJava API and \"pydoc ids\" for the Python. In addition the \n<a href=\"/user-documentation/python-icat/\">Python ICAT</a> client\nsupports the IDS.</p>\n<h1>Calls</h1>\n<p>This is not a complete list of calls but just an overview to get\nstarted. The exact name depends on whether you are invoking the REST\ncalls directly of are using one of the client APIs. The names listed\nhere are the names of the resource in the REST call. Many calls accept\nlists of IDs of investigation, datasets and datafiles.</p>\n<h2>put -- store a file</h2>\n<p>This operation needs an existing Dataset in ICAT to link it to. From a\nserver perspective the data is streamed in the body of the message. Only\none file may be stored with one call. After the call the data stream\nwill have been stored as a file and will be catalogued as a Datafile.</p>\n<h2>get -- get a file or files</h2>\n<p>This operation requires either lists of IDs of investigations, datasets\nand datafiles or a preparedId (from a prepareData call) which identifies\nlists of IDs of investigation, datasets and datafiles. If multiple files\nmay be returned a zip file will be used to wrap the files. As soon as\nthe server has checked that the data are all available streaming the\nresult will start.</p>\n<h2>prepareData</h2>\n<p>This operation requires lists of IDs of investigations, datasets and\ndatafiles and returns a preparedId. It may be used with one level\nstorage though, as there is no preparatory work to be done, the only\nbenefit is that the preparedId may be shared with other people to permit\na \"get\" call to be made without having to login to ICAT and thereby make\ndata available to those who would not normally have permission to read\nit.</p>\n<h2>getLink</h2>\n<p>This is a call to provide efficient access to a data file. It is only of\nuse if the file system hosting main storage is accessible to the user.\n It returns an absolute path which is hard link to the file which has a\nserver defined lifetime. It is expected to be used from a program which\ncalls getLink and then immediately opens the file. Even if the hard link\nis deleted by the server the file remains accessible because of the open\nfile handle.  ACLs are set on the link to only allow read access to the\n user specified in the getLink call. In the case of the Java API this is\nobtained by  looking up the system property \"user.name\" and the Python\nuses getuser() from the getpass package.</p>","frontmatter":{"title":"ICAT Data Service","date":null}}},"pageContext":{"slug":"/user-documentation/icat-data-service/"}},"staticQueryHashes":["2186722355","3212510956","3248290905","3649515864","4121107168"],"slicesMap":{}}